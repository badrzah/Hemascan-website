export interface PreprocessedImage {
  data: Float32Array;
  shape: number[];
  originalSize: { width: number; height: number };
}

export interface ImagePreprocessingOptions {
  targetSize: number; // e.g., 224 for typical CNN models
  normalize: boolean;
  mean?: number[];
  std?: number[];
}

/**
 * Image preprocessing utility for ONNX model input
 */
export class ImagePreprocessor {
  private options: ImagePreprocessingOptions;

  constructor(options: ImagePreprocessingOptions = {
    targetSize: 224,
    normalize: true,
    mean: [0.485, 0.456, 0.406], // ImageNet normalization
    std: [0.229, 0.224, 0.225]
  }) {
    this.options = options;
  }

  /**
   * Preprocess an image file for ONNX model input
   */
  async preprocessImage(file: File): Promise<PreprocessedImage> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          if (!ctx) {
            reject(new Error('Could not get canvas context'));
            return;
          }

          // Store original size
          const originalSize = { width: img.width, height: img.height };
          
          // Resize image to target size
          canvas.width = this.options.targetSize;
          canvas.height = this.options.targetSize;
          
          // Draw and resize image
          ctx.drawImage(img, 0, 0, this.options.targetSize, this.options.targetSize);
          
          // Get image data
          const imageData = ctx.getImageData(0, 0, this.options.targetSize, this.options.targetSize);
          
          // Convert to Float32Array and normalize
          const processedData = this.convertToFloat32Array(imageData);
          
          resolve({
            data: processedData,
            shape: [1, 3, this.options.targetSize, this.options.targetSize], // NCHW format
            originalSize
          });
          
        } catch (error) {
          reject(new Error(`Image preprocessing failed: ${error}`));
        }
      };
      
      img.onerror = () => {
        reject(new Error('Failed to load image'));
      };
      
      // Load image from file
      const reader = new FileReader();
      reader.onload = (e) => {
        img.src = e.target?.result as string;
      };
      reader.onerror = () => {
        reject(new Error('Failed to read image file'));
      };
      reader.readAsDataURL(file);
    });
  }

  /**
   * Preprocess an image from URL or base64 string
   */
  async preprocessImageFromUrl(imageUrl: string): Promise<PreprocessedImage> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          if (!ctx) {
            reject(new Error('Could not get canvas context'));
            return;
          }

          // Store original size
          const originalSize = { width: img.width, height: img.height };
          
          // Resize image to target size
          canvas.width = this.options.targetSize;
          canvas.height = this.options.targetSize;
          
          // Draw and resize image
          ctx.drawImage(img, 0, 0, this.options.targetSize, this.options.targetSize);
          
          // Get image data
          const imageData = ctx.getImageData(0, 0, this.options.targetSize, this.options.targetSize);
          
          // Convert to Float32Array and normalize
          const processedData = this.convertToFloat32Array(imageData);
          
          resolve({
            data: processedData,
            shape: [1, 3, this.options.targetSize, this.options.targetSize], // NCHW format
            originalSize
          });
          
        } catch (error) {
          reject(new Error(`Image preprocessing failed: ${error}`));
        }
      };
      
      img.onerror = () => {
        reject(new Error('Failed to load image from URL'));
      };
      
      img.src = imageUrl;
    });
  }

  /**
   * Convert ImageData to Float32Array with normalization
   */
  private convertToFloat32Array(imageData: ImageData): Float32Array {
    const { data, width, height } = imageData;
    const channels = 3;
    const totalPixels = width * height;
    
    // Create Float32Array for RGB channels (NCHW format)
    const floatArray = new Float32Array(channels * totalPixels);
    
    // Convert RGBA to RGB and normalize
    for (let i = 0; i < totalPixels; i++) {
      const pixelIndex = i * 4; // RGBA format
      
      // Extract RGB values (0-255)
      const r = data[pixelIndex];
      const g = data[pixelIndex + 1];
      const b = data[pixelIndex + 2];
      
      if (this.options.normalize && this.options.mean && this.options.std) {
        // Normalize using ImageNet statistics
        floatArray[i] = (r / 255.0 - this.options.mean[0]) / this.options.std[0]; // R channel
        floatArray[totalPixels + i] = (g / 255.0 - this.options.mean[1]) / this.options.std[1]; // G channel
        floatArray[2 * totalPixels + i] = (b / 255.0 - this.options.mean[2]) / this.options.std[2]; // B channel
      } else {
        // Simple normalization to [0, 1]
        floatArray[i] = r / 255.0; // R channel
        floatArray[totalPixels + i] = g / 255.0; // G channel
        floatArray[2 * totalPixels + i] = b / 255.0; // B channel
      }
    }
    
    return floatArray;
  }

  /**
   * Update preprocessing options
   */
  updateOptions(newOptions: Partial<ImagePreprocessingOptions>): void {
    this.options = { ...this.options, ...newOptions };
  }

  /**
   * Get current preprocessing options
   */
  getOptions(): ImagePreprocessingOptions {
    return { ...this.options };
  }
}

// Default preprocessor instance
export const defaultPreprocessor = new ImagePreprocessor();

/**
 * Quick preprocessing function for common use cases
 */
export async function preprocessImageForModel(
  file: File, 
  targetSize: number = 224
): Promise<PreprocessedImage> {
  const preprocessor = new ImagePreprocessor({ targetSize });
  return preprocessor.preprocessImage(file);
}
